# AEP 7: Queue system interface design

|                     |ArmoniK Enhancement Proposal|
|---:                 |:--- |
| **AEP**             | 7 |
| **Title**           | Queue system interface design |
| **Author**          | Jérôme Gurhem <<jgurhem@aneo.fr>> |
| **Status**          | Active |
| **Type**            | Standard |
| **Creation Date**   | 2025-01-15 |

# Abstract

This proposal outlines the rationale and design decisions behind the current message processing and lifecycle management system in ArmoniK. It highlights the primary reasons for adopting a pull-based model, discusses design constraints, and evaluates the trade-offs involved in ensuring reliability and robustness for long-running tasks.

# Motivation

The main motivation for the current architecture is to maintain a historical interface that provides comprehensive traceability and monitoring of tasks and message processing. This interface is central to operational observability and is a key requirement for the system.

# Rationale

## Strict Control of Message Processing

The system is designed to enforce strict control over the number of messages being processed and their lifecycle. Each message in the system represents an executable task with a well-defined processing flow. An executable task is a task whose dependencies were completed, thus being queued for execution. When a message is received, the corresponding task begins execution. The message is acknowledged only after the task completes, regardless of whether it succeeds or fails. In cases where the queueing service loses its connection with the agent before the message is acknowledged, the system ensures reliability by redelivering the message. This guarantees that tasks are not lost and are executed even when errors or interruptions occur.

Retries for tasks are handled by treating them as new tasks. Each retry is introduced as a new message, which simplifies tracking and execution. Messages are acknowledged when the task completes successfully and subtasks are submitted. ArmoniK processes new messages only after the current task has been dispatched to a worker, starting the acquisition of a new task during the processing of the previous one. This design allows to have a task ready for execution as soon as the previous task ends.

## Trade-offs and Constraints

Rewriting the codebase to adopt a fully event-driven, push-based pattern is not feasible given the complexity and scale of such a transformation. The current design prioritizes simplicity and robustness over a pure event-driven model. Considering the long duration of tasks and the cost of orchestration, some inefficiencies during message reception are acceptable. These inefficiencies are preferable to the development overhead and technical debt involved in transforming the existing pull-based mechanism.

The technical limitations of the underlying queueing service also play a role in the design decisions. SQS, for instance, does not provide an API for push-based message reception, which necessitates the use of a pull-based approach. Additionally, past attempts to use RabbitMQ for push-based message handling revealed significant stability issues, such as connection losses and inconsistent message processing. These challenges have further reinforced the decision to rely on the pull-based model, which offers greater reliability and predictability.

We can consider converting a push-based reception to messages into our pull-based interfaces. However, this implementation requires to be as stable as the current one. Pull requests are welcome to improve the implementation of our queue system adaptors.

# Conclusion

The architecture reflects a deliberate balance between design complexity, operational requirements, and system constraints. By combining a historical interface with strict control over message processing and lifecycle management, ArmoniK achieves a reliable and scalable system. Although the system does not adopt a fully event-driven approach, it remains robust and resilient, meeting the demands of long-running tasks and orchestration challenges. The trade-offs in this design are justified by the system’s operational stability and its ability to handle large-scale workloads efficiently.

# Copyright

This document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive
